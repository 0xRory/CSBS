第一个函数eventadd是添加一个事件, Community Owner是社区拥有者，实际上可能不需要，因为调用者调用，自然就成为所有人了，同时还有一个签名者CommunitySigner，为什么要这样设计呢？因为拥有者可能是个合约，没有办法单独进行签名，所以需要一个人单独签名。

然后需要填写event的uri，比如说是个结构化的json，然后可以在网站上展示出来这个事件，还有发的nft的uri的前缀，之后可以在mint的时候省点钱，eventupdate函数可以改一下eventuri和basetokenuri的数据，eventControllerUpdate可以更新新的签名者与新的拥有者

然后是授予NFT的部分，这是两个，一个是社区主动发放的，比如说这次大理web3是主动发放的，只要是呃，只要是来自于这两个地址的。调用。就可以直接往这个地址里转NFT。还有一个是用户自己调用的，然后他拿到了社区的签名者的签名，在合约里验证，说这个签名里确实支持他在某个event下命某个tokenuri、basetokenuri有对应关系的话，就可以直接mint

第一个awards函数还要加一个判断，调用是否是owner，第二个awards函数调用的时候，要验证下签名者的签名，转让sbt函数，只要有了这个签名者的签名还有sbt所有者调用的时候，就可以把这个sbt转移到新的地址，呃，这个应该是呃现实的情况应该是我有一个sbt，但是我的地址怀疑是要泄露了，或者我不想用这个地址了，我要联系，比如说web3大理官方

项目方我跟他说我从哪个地址要转到哪个地址，你给我一条签名的信息就是就是这个给了我之后我自己调用它就行了，就就转允许转一次。

signature是哪个函数给的呢，是上面的newCommunitysigner的变量，用这个地址，签名tokenId、newaddress、oldaddress。这个解决了账户抽象私钥丢失，又不能让他买卖的问题，签名是在链下签的，签完就通过微信也好，网站也好，显示在那里。接下来就是写了一个transfer的报错，然后就没了。在721合约标准里有三个transfer函数

ERC721A 的benchcall 给用户发也会很便宜，可以直接把方法扒过去用

批量铸造，第一个awards函数就可以了

有一个提议，可以加一个mapping，任何人都可以往里面写键值对，比如地址是HM的地址，值是贡献值，做一个k、v存起来，可以任意人都可以写入



